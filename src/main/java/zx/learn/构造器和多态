

### 尽管构造器不具有多态性（它们实际上是静态方法，但是隐式声明的）


在派生类的构造过程中总会调用基类的构造器。
初始化会自动按继承层次结构上移，因此每个基类的构造器都会被调用到。
这么做是有意义的，因为构造器有着特殊的任务：检查对象是否被正确地构造。
由于属性通常声明为 private，你必须假定派生类只能访问自己的成员而不能访问基类的成员。
只有基类的构造器拥有恰当的知识和权限来初始化自身的元素。
因此，必须得调用所有构造器；否则就不能构造完整的对象。
这就是编译器强制每个派生类部分必须调用构造器的原因。
如果在派生类的构造器主体中没有显式地调用基类构造器，编译器就会默默地调用无参构造器。
如果没有无参构造器，编译器就会报错（当类中不含构造器时，编译器会自动合成一个无参构造器）。

编写构造器有一条良好规范：

做尽量少的事让对象进入良好状态。
如果有可能的话，尽量不要调用类中的任何方法。
在构造器中唯一能安全调用的只有基类的 final 方法
（包括 private 方法，它们自动属于 final）。
这些方法不能被覆写，因此不会产生意想不到的结果。
你可能无法永远遵循这条规范，但应该朝着它努力。

java 虚拟机 内存结构，ClassLoader，